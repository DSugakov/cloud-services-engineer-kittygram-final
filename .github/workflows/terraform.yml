name: Terraform Infrastructure

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Select the Terraform action'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  TF_VERSION: '1.5.0'
  YC_SERVICE_ACCOUNT_KEY_FILE: ${{ secrets.YC_SERVICE_ACCOUNT_KEY_FILE }}
  YC_CLOUD_ID: ${{ secrets.YC_CLOUD_ID }}
  YC_FOLDER_ID: ${{ secrets.YC_FOLDER_ID }}
  TF_VAR_existing_network_id: ${{ secrets.EXISTING_NETWORK_ID }}
  TF_VAR_existing_subnet_id: ${{ secrets.EXISTING_SUBNET_ID }}
  TF_VAR_existing_security_group_id: ${{ secrets.EXISTING_SECURITY_GROUP_ID }}
  TF_VAR_existing_instance_id: ${{ secrets.EXISTING_INSTANCE_ID }}

jobs:
  terraform:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./infra
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Create service account key file
        run: |
          # Создаем Python скрипт для обработки JSON
          cat > create_key.py << 'EOF'
          import json
          import re
          import os
          import sys
          
          def create_key_file():
              # Получаем содержимое секрета из переменной окружения
              secret_content = os.environ.get('YC_SERVICE_ACCOUNT_KEY_FILE', '')
              
              if not secret_content:
                  print('Ошибка: YC_SERVICE_ACCOUNT_KEY_FILE не установлен')
                  sys.exit(1)
              
              print('Обрабатываем JSON секрет...')
              print(f'Длина секрета: {len(secret_content)} символов')
              
              try:
                  # Очищаем управляющие символы, кроме \n и \r
                  cleaned_content = re.sub(r'[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]', '', secret_content)
                  
                  # Дополнительная очистка: удаляем символы, которые могут нарушать JSON
                  cleaned_content = re.sub(r'[^\x20-\x7E\n\r]', '', cleaned_content)
                  
                  # Исправляем возможные проблемы с кавычками и экранированием
                  cleaned_content = cleaned_content.replace('\\"', '"').replace('\\n', '\\n')
                  
                  print(f'Очищенный контент (первые 200 символов): {repr(cleaned_content[:200])}')
                  
                  # Парсим JSON
                  data = json.loads(cleaned_content)
                  
                  # Исправляем \n в private_key (заменяем \\n на реальные переносы строк)
                  if 'private_key' in data:
                      data['private_key'] = re.sub(r'\\\\n', '\n', data['private_key'])
                  
                  # Сохраняем исправленный JSON
                  with open('key.json', 'w') as f:
                      json.dump(data, f, indent=2)
                  
                  print('JSON файл успешно создан')
                  
                  # Проверяем, что файл создан и содержит валидный JSON
                  with open('key.json', 'r') as f:
                      test_data = json.load(f)
                  print(f'Проверка: файл содержит {len(test_data)} полей')
                  
              except json.JSONDecodeError as e:
                  print(f'Ошибка парсинга JSON: {e}')
                  print(f'Позиция ошибки: строка {e.lineno}, столбец {e.colno}')
                  print(f'Проблемный фрагмент: {repr(cleaned_content[max(0, e.pos-50):e.pos+50])}')
                  
                  # Дополнительная диагностика
                  print(f'Символы вокруг ошибки:')
                  start = max(0, e.pos-20)
                  end = min(len(cleaned_content), e.pos+20)
                  problem_area = cleaned_content[start:end]
                  print(f'  {repr(problem_area)}')
                  
                  # Попробуем найти и исправить проблемные символы
                  print('Попытка дополнительной очистки...')
                  # Удаляем все символы, которые точно не должны быть в JSON
                  ultra_cleaned = re.sub(r'[^\x20-\x7E\n\r\t]', '', cleaned_content)
                  try:
                      data = json.loads(ultra_cleaned)
                      print('Успешно после дополнительной очистки!')
                      # Сохраняем исправленный JSON
                      with open('key.json', 'w') as f:
                          json.dump(data, f, indent=2)
                      print('JSON файл успешно создан после очистки')
                      return
                  except json.JSONDecodeError as e2:
                      print(f'Дополнительная очистка не помогла: {e2}')
                  
                  sys.exit(1)
              except Exception as e:
                  print(f'Неожиданная ошибка: {e}')
                  sys.exit(1)
          
          if __name__ == '__main__':
              create_key_file()
          EOF
          
          # Запускаем Python скрипт
          python3 create_key.py
          
          # Устанавливаем права доступа
          chmod 600 key.json
          
          # Удаляем временный скрипт
          rm create_key.py
        env:
          YC_SERVICE_ACCOUNT_KEY_FILE: ${{ secrets.YC_SERVICE_ACCOUNT_KEY_FILE }}

      - name: Terraform Init
        run: |
          echo "Инициализация Terraform..."
          terraform init -upgrade
          echo "Terraform успешно инициализирован"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.YC_STORAGE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.YC_STORAGE_SECRET_KEY }}
          AWS_DEFAULT_REGION: ru-central1
          AWS_S3_FORCE_PATH_STYLE: 'true'

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        if: ${{ github.event.inputs.action == 'plan' }}
        run: |
          terraform plan \
            -var="cloud_id=${{ secrets.YC_CLOUD_ID }}" \
            -var="folder_id=${{ secrets.YC_FOLDER_ID }}" \
            -var="service_account_key_file=key.json" \
            -var="storage_access_key=${{ secrets.YC_STORAGE_ACCESS_KEY }}" \
            -var="storage_secret_key=${{ secrets.YC_STORAGE_SECRET_KEY }}"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.YC_STORAGE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.YC_STORAGE_SECRET_KEY }}
          AWS_DEFAULT_REGION: ru-central1
          AWS_S3_FORCE_PATH_STYLE: 'true'

      - name: Terraform Apply
        if: ${{ github.event.inputs.action == 'apply' }}
        run: |
          terraform apply -auto-approve \
            -var="cloud_id=${{ secrets.YC_CLOUD_ID }}" \
            -var="folder_id=${{ secrets.YC_FOLDER_ID }}" \
            -var="service_account_key_file=key.json" \
            -var="storage_access_key=${{ secrets.YC_STORAGE_ACCESS_KEY }}" \
            -var="storage_secret_key=${{ secrets.YC_STORAGE_SECRET_KEY }}"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.YC_STORAGE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.YC_STORAGE_SECRET_KEY }}
          AWS_DEFAULT_REGION: ru-central1
          AWS_S3_FORCE_PATH_STYLE: 'true'

      - name: Get outputs
        if: ${{ github.event.inputs.action == 'apply' }}
        run: |
          echo "Получение outputs Terraform..."
          echo "VM External IP: $(terraform output -raw vm_external_ip)"
          echo "Kittygram URL: $(terraform output -raw kittygram_url)"
          echo "Outputs успешно получены"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.YC_STORAGE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.YC_STORAGE_SECRET_KEY }}
          AWS_DEFAULT_REGION: ru-central1
          AWS_S3_FORCE_PATH_STYLE: 'true'

      - name: Terraform Destroy
        if: ${{ github.event.inputs.action == 'destroy' }}
        run: |
          terraform destroy -auto-approve \
            -var="cloud_id=${{ secrets.YC_CLOUD_ID }}" \
            -var="folder_id=${{ secrets.YC_FOLDER_ID }}" \
            -var="service_account_key_file=key.json" \
            -var="storage_access_key=${{ secrets.YC_STORAGE_ACCESS_KEY }}" \
            -var="storage_secret_key=${{ secrets.YC_STORAGE_SECRET_KEY }}"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.YC_STORAGE_ACCESS_KEY }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.YC_STORAGE_SECRET_KEY }}
          AWS_DEFAULT_REGION: ru-central1
          AWS_S3_FORCE_PATH_STYLE: 'true'

      - name: Cleanup
        if: always()
        run: |
          rm -f key.json 